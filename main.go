package main

import (
	"bytes"
	"flag"
	"html/template"
	"path/filepath"

	"github.com/bakaoh/protoc-gen-zpi/extension"
	"github.com/golang/glog"
	"github.com/golang/protobuf/proto"
	plugin_go "github.com/golang/protobuf/protoc-gen-go/plugin"
	"github.com/pseudomuto/protokit"
)

func main() {
	flag.Parse()
	defer glog.Flush()

	if err := protokit.RunPlugin(new(plugin)); err != nil {
		glog.Fatal(err)
	}
}

type plugin struct{}

func (p *plugin) Generate(req *plugin_go.CodeGeneratorRequest) (*plugin_go.CodeGeneratorResponse, error) {
	descriptors := protokit.ParseCodeGenRequest(req)
	resp := new(plugin_go.CodeGeneratorResponse)

	for _, d := range descriptors {

		enums := []string{}
		for _, e := range d.EnumType {
			if i, err := proto.GetExtension(
				e.Options,
				extension.E_EnumIn,
			); err == nil && *i.(*bool) {
				enums = append(enums, *e.Name)
			}
		}

		if len(enums) == 0 {
			continue
		}

		w := bytes.NewBuffer(nil)
		fileName := *d.Name
		fileName = fileName[0:len(fileName)-len(filepath.Ext(fileName))] + ".zpi.go"

		if err := zpiTemplate.Execute(w, params{
			GoPkg: *d.Package,
			Enums: enums,
		}); err == nil {
			resp.File = append(resp.File, &plugin_go.CodeGeneratorResponse_File{
				Name:    proto.String(fileName),
				Content: proto.String(w.String()),
			})
		}
	}

	return resp, nil
}

type params struct {
	GoPkg string
	Enums []string
}

var (
	zpiTemplate = template.Must(template.New("zpi").Parse(
		`// Code generated by protoc-gen-zpi. DO NOT EDIT.

package {{.GoPkg}}
{{range $i := .Enums}}
// In return true if s contains t
func (t {{ $i }}) In(s []{{ $i }}) bool {
	for _, i := range s {
		if i == t {
			return true
		}
	}
	return false
}
{{end}}`))
)
